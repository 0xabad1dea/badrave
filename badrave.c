/* 
	B A D R A V E
	
	0 x A B A D 1 D E A
	
	badrave by @0xabad1dea (Melissa Elliott) Feb 2015
	this version not open source licensed
	
	generates procedural music in MML format to feed
	into pp-mck and thereby generate chiptunes.
	
	clang -Weverything -Wno-unused-macros -o badrave badrave.c

*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "badrave.h"

signed main(signed argc, char *argv[]) {
	/* tmp: bc I hate the clang warning */
	if(argc == 0 || argv == 0) exit(-1);
	
	/* todo: custom seeds */
	dword seed = (dword)time(NULL);
	srand((dword)seed);
	//printf("DEBUG: seed: 0x%X\n", seed);
	
	
	printMMLHeader(seed);
	
	byte* testMeasure = genMeasureRhythm();
	
	debugPrintPlayableMeasure(testMeasure);
	debugPrintPlayableMeasure(testMeasure);
	debugPrintPlayableMeasure(testMeasure);
	debugPrintPlayableMeasure(testMeasure);
	
	return 0;
}


/* generators */

/* return one of 2, 4, 8, 16 in an even-ish distribution favoring 4 */
/* these are in numerator units, ie, 2 is one half of a measure */
byte getOneBeat() {
	dword num = (dword)rand();
	if(num < 0x10000000) return 2;
	if(num < 0x20000000) return 8;
	if(num < 0x40000000) return 16;
	return 4; /* at least I think it favors 4. */
	
}

/* return one measure. zero-terminated. caller frees. */
byte* genMeasureRhythm() {
	byte beatsremaining = 16;
	byte noteslot = 0;
	byte* measure = malloc(17);
	
	while(beatsremaining != 0) {
		byte beat = getOneBeat();
		if(beat == 2) {
			// half notes only on start or half point of measure
			if(beatsremaining != 16 && beatsremaining != 8) {
				continue; }
			else {
				measure[noteslot] = 2;
				beatsremaining -= 8; 
				noteslot++; }}
		if(beat == 4) {
			if(beatsremaining < 4) {
				continue; }
			else {
				measure[noteslot] = 4;
				beatsremaining -= 4;
				noteslot++; }}
		if(beat == 8) {
			measure[noteslot] = 8;
			beatsremaining -= 2;
			noteslot++; }
		if(beat == 16) {
			// 16s always come in pairs
			measure[noteslot] = 16;
			noteslot++;
			measure[noteslot] = 16;
			noteslot++;
			beatsremaining -= 2; }
		}
		
		measure[noteslot] = 0; // terminate
	
	return measure;
}

void debugPrintMeasureRhythm(byte* measure) {
	printf("DEBUG: measure:\n");
	for (dword i = 0; i < 17; i++) {
	printf("%u ", measure[i]); }
	printf("\n");
}

/* renders a measure nominally playable for testing */
void debugPrintPlayableMeasure(byte* measure) {
	
	printf("A o3 @1 @v1 ");
	for(dword i = 0; i < 17; i++) {
		if(measure[i] != 0) {
			printf("a%u ", measure[i]); }
	}
	
	printf("\n");
}


void printMMLHeader(dword seed) {
	//todo: print to file rather than stdout lol
	//note that these mml metadata fields must be <= 31 chars
	
	printf("#TITLE\t\"badrave 0x%X\"\n", seed);
	printf("#COMPOSER\t\"generated by badrave\"\n");
	// yes, programer, spelled like that, because ???.
	printf("#PROGRAMER\t\"programmed by 0xabad1dea\"\n");
	printf("#MAKER\t\"badrave by 0xabad1dea\"\n");
	
	time_t now = time(NULL);
	printf("\n; generated at %s", ctime(&now));
	printf("; by %s with seed 0x%X\n\n", badversion, seed);
	
	// the library of mml macros we use
	printf("%s\n", volume1);
	// todo: more lol
	
	// tempo
	printf("\nABCD t%u\n", 150); // FIXME other tempos
	
}
