/* 
	B A D R A V E
	
	0 x A B A D 1 D E A
	
	badrave by @0xabad1dea (Melissa Elliott) Feb 2015
	
	generates procedural music in MML format to feed
	into pp-mck and thereby generate chiptunes.
	
	clang -Weverything -Wno-unused-macros -o badrave badrave.c
	gcc -std=c99 -Wall -Wno-unused-macros -Wno-unused-variable -o badrave strlcat.c badrave.c
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "badrave.h"

signed main(signed argc, char *argv[]) {
	/* fixme: bc I hate the clang warning */
	if(argc == 0 || argv == 0) exit(-1);
	
	/* todo: custom seeds */
	dword seed = (dword)time(NULL);
	srand((dword)seed);
	//printf("DEBUG: seed: 0x%X\n", seed);
	
	
	printMMLHeader(seed);
	
	byte* testMeasureAH = genMeasureRhythm(); // harmonious
	byte* testMeasureAN = genMeasureRhythm(); // naive
	byte* testMeasureB = genMeasureRhythm();
	//byte* testMeasureC = genMeasureRhythm();
	
	// tmp: give the channels some parameters
	printf("\nA %s %s %s\n", randomOctave(), randomTimbre(), randomVolume());
	printf("B %s %s %s\n", randomOctave(), randomTimbre(), randomVolume());
	printf("C %s q6\n", randomOctave());
	
	//char* testOutputAN = naiveNotePicker('A', fminor, testMeasureAN);
	char* testOutputAH = harmonyNotePicker('A', fminor, testMeasureAH);
	char* testOutputB = harmonyNotePicker('B', fminor, testMeasureB);
	char* testOutputC = harmonyNotePicker('C', fminor, testMeasureB);
	printf("%s\n%s\n%s\n%s\n", testOutputAH, testOutputAH, testOutputAH, testOutputAH);
	printf("%s\n%s\n%s\n%s\n", testOutputB, testOutputB, testOutputB, testOutputB);
	printf("%s\n%s\n%s\n%s\n", testOutputC, testOutputC, testOutputC, testOutputC);
	
	char* testOutputAN2 = naiveNotePicker('A', fminor, testMeasureAN);
	char* testOutputAH2 = harmonyNotePicker('A', fminor, testMeasureAH);
	//char* testOutputB2 = naiveNotePicker('B', fminor, testMeasureB);
	
	printf("%s\n%s\n%s\n%s\n", testOutputAH2, testOutputAH2, testOutputAN2, testOutputAH2);
	printf("%s\n%s\n%s\n%s\n", testOutputB, testOutputB, testOutputB, testOutputB);
	printf("%s\n%s\n%s\n%s\n", testOutputC, testOutputC, testOutputC, testOutputC);
	
	printf("\nA %s %s %s\n", randomOctave(), randomTimbre(), randomVolume());
	printf("B %s\n", randomOctave());
	
	printf("%s\n%s\n%s\n%s\n", testOutputAH, testOutputAH, testOutputAH, testOutputAH);
	printf("%s\n%s\n%s\n%s\n", testOutputB, testOutputB, testOutputB, testOutputB);
	printf("%s\n%s\n%s\n%s\n", testOutputC, testOutputC, testOutputC, testOutputC);
	
	printf("%s\n%s\n%s\n%s\n", testOutputAH2, testOutputAH2, testOutputAN2, testOutputAH2);
	printf("%s\n%s\n%s\n%s\n", testOutputB, testOutputB, testOutputB, testOutputB);
	printf("%s\n%s\n%s\n%s\n", testOutputC, testOutputC, testOutputC, testOutputC);
	
	
	return 0; }


/* generators */

/* return one of 2, 4, 8, 16 in an even-ish distribution favoring 4 */
/* these are in numerator units, ie, 2 is one half of a measure */
byte getOneBeat() {
	dword num = (dword)rand();
	if(num < 0x10000000) return 2;
	if(num < 0x20000000) return 8;
	if(num < 0x40000000) return 16;
	return 4; /* at least I think it favors 4. */ }

/* return one measure. zero-terminated. caller frees. */
byte* genMeasureRhythm() {
	byte beatsremaining = 16;
	byte noteslot = 0;
	byte* measure = malloc(17);
	if(!measure) exit(-1);
	
	while(beatsremaining != 0) {
		byte beat = getOneBeat();
		if(beat == 2) {
			// half notes only on start or half point of measure
			if(beatsremaining != 16 && beatsremaining != 8) {
				continue; }
			else {
				measure[noteslot] = 2;
				beatsremaining -= 8; 
				noteslot++; } }
		if(beat == 4) {
			if(beatsremaining < 4) {
				continue; }
			else {
				measure[noteslot] = 4;
				beatsremaining -= 4;
				noteslot++; } }
		if(beat == 8) {
			measure[noteslot] = 8;
			beatsremaining -= 2;
			noteslot++; }
		if(beat == 16) {
			// 16s always come in pairs
			measure[noteslot] = 16;
			noteslot++;
			measure[noteslot] = 16;
			noteslot++;
			beatsremaining -= 2; } 
		continue; }
		
		measure[noteslot] = 0; // terminate
	
	return measure; }

void debugPrintMeasureRhythm(byte* measure) {
	printf("DEBUG: measure:\n");
	for (dword i = 0; i < 17; i++) {
	printf("%u ", measure[i]); }
	printf("\n");
	return; }

/* renders a measure nominally playable for testing */
void debugPrintPlayableMeasure(byte* measure) {
	
	printf("A o3 @1 @v1 ");
	for(dword i = 0; i < 17; i++) {
		if(measure[i] != 0) {
			printf("a%u ", measure[i]); } }
	
	printf("\n");
	return; }


/* generate the header with metadata */
void printMMLHeader(dword seed) {
	//todo: print to file rather than stdout lol
	//note that these mml metadata fields must be <= 31 chars
	
	printf("#TITLE\t\t\"badrave 0x%X\"\n", seed);
	printf("#COMPOSER\t\"generated by badrave\"\n");
	// yes, programer, spelled like that, because ???.
	printf("#PROGRAMER\t\"programmed by 0xabad1dea\"\n");
	printf("#MAKER\t\t\"badrave by 0xabad1dea\"\n");
	
	time_t now = time(NULL);
	printf("\n; generated at %s", ctime(&now)); // lazy
	printf("; by %s with seed 0x%X\n\n", badversion, seed);
	
	// the library of mml macros we use
	printf("%s\n%s\n%s\n%s\n", volume1, volume9, volume15, volume16);
	printf("%s\n%s\n%s\n%s\n", volume21, volume23, volume26, volume27);
	
	printf("%s\n%s\n%s\n%s\n", atat4, atat7, atat10, atat21);
	// todo: more lol
	
	// tempo
	printf("\nABCD t%u\n", 150); // FIXME other tempos
	
	return; }

/* assigns notes only from 1st, 3rd, 5th, 7th for a harmonious sound */
char* harmonyNotePicker(char channel, char** key, byte* measure) {
	char* output = malloc(150);
	if(!output) exit(-1);

	byte notes[17];

	byte count; 
	for(count = 0; count < 17; count++) {
		if(measure[count] == 0) { break; } }

	dword rando;
	for(byte i = 0; i < count; i++) {
		rando = (dword)rand();
		if((rando & 0x3) == 0) { notes[i] = 0; continue; }
		if((rando & 0x3) == 1) { notes[i] = 2; continue; }
		if((rando & 0x3) == 2) { notes[i] = 3; continue; }
		if((rando & 0x3) == 3) { notes[i] = 4; continue; }
		// think that's everything but
		notes[i] = 7; }
		
		rando = (dword)rand();
		// start and end on the base note of the key, either low or high.
		if(rando & 0x1) { notes[0] = 0; notes[count-1] = 0; }
		else { notes[0] = 7; notes[count-1] = 7; }

	// print channel
	snprintf(output, 8, "%c ", channel);
	char tmp[8];
	for(byte i = 0; i < count; i++) {
		if(notes[i] == 7) { snprintf(tmp, 7, ">%s%u< ", key[notes[i]], measure[i]); }
		else { snprintf(tmp, 7, "%s%u ", key[notes[i]], measure[i]); }
		// 16 notes * 8 characters == 128. buffer is 150.
		strlcat(output, tmp, 149); }

	return output; }


/* assigns notes arbitrarily */
char* naiveNotePicker(char channel, char** key, byte* measure) {
	char* output = malloc(150);
	if(!output) exit(-1);

	byte notes[17];

	byte count; 
	for(count = 0; count < 17; count++) {
		if(measure[count] == 0) { break; } }

	dword rando;
	for(byte i = 0; i < count; i++) {
		rando = (dword)rand();
		if((rando & 0x7) == 1) { notes[i] = 0; continue; }
		if((rando & 0x7) == 2) { notes[i] = 1; continue; }
		if((rando & 0x7) == 3) { notes[i] = 2; continue; }
		if((rando & 0x7) == 4) { notes[i] = 3; continue; }
		if((rando & 0x7) == 5) { notes[i] = 4; continue; }
		if((rando & 0x7) == 6) { notes[i] = 5; continue; }
		if((rando & 0x7) == 7) { notes[i] = 6; continue; }
		notes[i] = 7; }
		
		rando = (dword)rand();
		// start and end on the base note of the key, either low or high.
		if(rando & 0x1) { notes[0] = 0; notes[count-1] = 0; }
		else { notes[0] = 7; notes[count-1] = 7; } 

	// print channel
	snprintf(output, 8, "%c ", channel);
	char tmp[8];
	for(byte i = 0; i < count; i++) {
		if(notes[i] == 7) { snprintf(tmp, 7, ">%s%u< ", key[notes[i]], measure[i]); }
		else { snprintf(tmp, 7, "%s%u ", key[notes[i]], measure[i]); }
		// 16 notes * 8 characters == 128. buffer is 150.
		strlcat(output, tmp, 149); }

	return output; }

// one of o2 .. o5
char* randomOctave() {
	dword rando = (dword)rand();
	if((rando & 0x3) == 0) { return o2; }
	if((rando & 0x3) == 1) { return o3; }
	if((rando & 0x3) == 2) { return o4; }
	if((rando & 0x3) == 3) { return o5; }
	return o3; }
	
// return a volume parameter
char* randomVolume() {
	dword rando = (dword)rand();
	if((rando & 0x7) == 0) { return "@v1"; }
	if((rando & 0x7) == 1) { return "@v9"; }
	if((rando & 0x7) == 2) { return "@v15"; }
	if((rando & 0x7) == 3) { return "@v16"; }
	if((rando & 0x7) == 4) { return "@v21"; }
	if((rando & 0x7) == 5) { return "@v23"; }
	if((rando & 0x7) == 6) { return "@v26"; }
	if((rando & 0x7) == 7) { return "@v27"; }
	return volume1; }
	
char* randomTimbre() {
	dword rando = (dword)rand();
	if((rando & 0x7) == 0) { return at0; }
	if((rando & 0x7) == 1) { return at1; }
	if((rando & 0x7) == 2) { return at2; }
	if((rando & 0x7) == 3) { return at3; }
	if((rando & 0x7) == 4) { return at4; }
	if((rando & 0x7) == 5) { return at7; }
	if((rando & 0x7) == 6) { return at10; }
	if((rando & 0x7) == 7) { return at21; }
	return at2; }
