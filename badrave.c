/* 
	B A D R A V E
	
	0 x A B A D 1 D E A
	
	badrave by @0xabad1dea (Melissa Elliott) Feb 2015
	this version not open source licensed
	
	generates procedural music in MML format to feed
	into pp-mck and thereby generate chiptunes.
	
	clang -Weverything -Wno-unused-macros -o badrave badrave.c

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "badrave.h"

signed main(signed argc, char *argv[]) {
	/* fixme: bc I hate the clang warning */
	if(argc == 0 || argv == 0) exit(-1);
	
	/* todo: custom seeds */
	dword seed = (dword)time(NULL);
	srand((dword)seed);
	//printf("DEBUG: seed: 0x%X\n", seed);
	
	
	printMMLHeader(seed);
	
	byte* testMeasure = genMeasureRhythm();
	
	// tmp: give the channels some parameters
	printf("\nA o3 @1 @v1\nB o2 @2 @v1\n");
	
	char* testOutputA = naiveNotePicker('A', aminor, testMeasure);
	char* testOutputB = naiveNotePicker('B', aminor, testMeasure);
	printf("%s\n%s\n%s\n%s\n", testOutputA, testOutputA, testOutputA, testOutputA);
	printf("%s\n%s\n%s\n%s\n", testOutputB, testOutputB, testOutputB, testOutputB);
	
	
	return 0; }


/* generators */

/* return one of 2, 4, 8, 16 in an even-ish distribution favoring 4 */
/* these are in numerator units, ie, 2 is one half of a measure */
byte getOneBeat() {
	dword num = (dword)rand();
	if(num < 0x10000000) return 2;
	if(num < 0x20000000) return 8;
	if(num < 0x40000000) return 16;
	return 4; /* at least I think it favors 4. */ }

/* return one measure. zero-terminated. caller frees. */
byte* genMeasureRhythm() {
	byte beatsremaining = 16;
	byte noteslot = 0;
	byte* measure = malloc(17);
	if(!measure) exit(-1);
	
	while(beatsremaining != 0) {
		byte beat = getOneBeat();
		if(beat == 2) {
			// half notes only on start or half point of measure
			if(beatsremaining != 16 && beatsremaining != 8) {
				continue; }
			else {
				measure[noteslot] = 2;
				beatsremaining -= 8; 
				noteslot++; } }
		if(beat == 4) {
			if(beatsremaining < 4) {
				continue; }
			else {
				measure[noteslot] = 4;
				beatsremaining -= 4;
				noteslot++; } }
		if(beat == 8) {
			measure[noteslot] = 8;
			beatsremaining -= 2;
			noteslot++; }
		if(beat == 16) {
			// 16s always come in pairs
			measure[noteslot] = 16;
			noteslot++;
			measure[noteslot] = 16;
			noteslot++;
			beatsremaining -= 2; } 
		continue; }
		
		measure[noteslot] = 0; // terminate
	
	return measure; }

void debugPrintMeasureRhythm(byte* measure) {
	printf("DEBUG: measure:\n");
	for (dword i = 0; i < 17; i++) {
	printf("%u ", measure[i]); }
	printf("\n");
	return; }

/* renders a measure nominally playable for testing */
void debugPrintPlayableMeasure(byte* measure) {
	
	printf("A o3 @1 @v1 ");
	for(dword i = 0; i < 17; i++) {
		if(measure[i] != 0) {
			printf("a%u ", measure[i]); } }
	
	printf("\n");
	return; }


/* generate the header with metadata */
void printMMLHeader(dword seed) {
	//todo: print to file rather than stdout lol
	//note that these mml metadata fields must be <= 31 chars
	
	printf("#TITLE\t\t\"badrave 0x%X\"\n", seed);
	printf("#COMPOSER\t\"generated by badrave\"\n");
	// yes, programer, spelled like that, because ???.
	printf("#PROGRAMER\t\"programmed by 0xabad1dea\"\n");
	printf("#MAKER\t\t\"badrave by 0xabad1dea\"\n");
	
	time_t now = time(NULL);
	printf("\n; generated at %s", ctime(&now)); // lazy
	printf("; by %s with seed 0x%X\n\n", badversion, seed);
	
	// the library of mml macros we use
	printf("%s\n", volume1);
	// todo: more lol
	
	// tempo
	printf("\nABCD t%u\n", 150); // FIXME other tempos
	
	return; }

/* assigns notes arbitrarily from key to measure. */
char* naiveNotePicker(char channel, char** key, byte* measure) {
	char* output = malloc(150);
	if(!output) exit(-1);
	
	byte notes[17];
	
	byte count; 
	for(count = 0; count < 17; count++) {
		if(measure[count] == 0) { break; } }
		
	dword rando = (dword)rand();
	// start and end on the base note of the key, either low or high.
	if(rando & 0x1) { notes[0] = 0; notes[count] = 0; }
	else { notes[0] = 7; notes[count] = 7; }
	
	for(byte i = 1; i < count-1; i++) {
		rando = (dword)rand();
		if((rando & 0x7) == 1) { notes[i] = 0; continue; }
		if((rando & 0x7) == 2) { notes[i] = 1; continue; }
		if((rando & 0x7) == 3) { notes[i] = 2; continue; }
		if((rando & 0x7) == 4) { notes[i] = 3; continue; }
		if((rando & 0x7) == 5) { notes[i] = 4; continue; }
		if((rando & 0x7) == 6) { notes[i] = 5; continue; }
		if((rando & 0x7) == 7) { notes[i] = 6; continue; }
		// think that's everything but
		notes[i] = 7; }
		
	// print channel
	snprintf(output, 8, "%c ", channel);
	char tmp[8];
	for(byte i = 0; i < count; i++) {
		snprintf(tmp, 7, "%s%u ", key[notes[i]], measure[i]);
		// 16 notes * 8 characters == 128. buffer is 150.
		strlcat(output, tmp, 149); }
		
	
	return output; }
